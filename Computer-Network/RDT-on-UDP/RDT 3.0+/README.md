# RDT 3.0 + 파이프라이닝

---

## 1. 패킷 구조  
패킷은 8바이트 헤더와 payload로 구성된다.  
헤더 구성은 다음과 같다.  
- **checkSum (2바이트):** 패킷 전체의 무결성을 검증하기 위해 계산된 체크섬이다.
- **end_flag (1바이트):** 0이면 마지막 패킷임을, 1이면 전송 중인 패킷임을 나타낸다.  
- **window_Size (1바이트):** 윈도우 크기를 나타낸다.
- **seq_num (4바이트):** 시퀀스 번호로, 패킷의 순서를 관리한다.

---

## 2. Receiver 동작 방식

1. **초기화 및 설정**  
   - 파일 이름을 받아 파일을 쓰기 모드로 연다.  
   - 초기 시퀀스 번호를 0으로 설정한다.  
   - 수신 과정에서 사용할 버퍼(buffer), 윈도우 크기(window size), 시퀀스 번호 공간(base) 및 종료 여부(end_flag)를 초기화한다.

2. **소켓 생성 및 바인딩**  
   - UDP 소켓을 생성하고 `SO_REUSEADDR` 옵션을 설정한 후 포트 10090번에 바인딩한다.

3. **패킷 수신 및 처리**  
   - UDP 소켓을 통해 1500바이트 단위로 패킷을 수신한다.
   - 수신한 패킷의 체크섬을 `verify_checksum()`로 검증한다.  
     - 체크섬 검증에 실패하면 해당 패킷은 무시한다.
   - 헤더에서 end_flag, window_size, seq_num을 추출한다.
   - 초기 패킷일 경우, 수신한 window_size로 윈도우 크기를 설정하고, 시퀀스 번호 공간(base)을 `window_size * 2`로 정하며, 동일 길이의 버퍼를 생성한다.
   - 수신된 seq_num이 현재 윈도우에 포함되는지 `is_in_window()` 함수로 확인한다.
   - 포함되면 버퍼의 해당 위치에 (end_flag, payload)를 저장한다.
   - 만약 수신된 seq_num이 기대하는 순서(seq_num와 다르면) WRONG_SEQ_NUM_BUFFER 로그를 기록한다.
   - ACK를 생성하여 송신자에게 전송한다.
   - 이후, `move_buffer()` 함수를 호출하여 버퍼 내 연속적으로 도착한 패킷들을 순서대로 파일에 기록하고, 기대하는 시퀀스 번호를 업데이트한다.
   - 버퍼 내에서 end_flag가 0인 패킷이 기록되면 전송 종료 플래그를 설정한다.

4. **종료 처리**  
   - end_flag가 설정되면 수신 루프를 종료하고, 로그 기록을 마친다.

---

## 3. Sender 동작 방식

1. **초기화 및 윈도우 구성**  
   - 전송할 파일의 크기를 확인하고 파일을 읽기 모드로 연다.
   - Payload 객체를 생성하며, 인자로 전달된 window_size로 윈도우를 구성한다.
   - 시퀀스 번호 공간(base)은 `window_size * 2`로 정하고, deque를 이용해 초기 윈도우를 채운다.
   - 각 패킷은 __get_payload()를 통해 생성되며,  
     - end_flag, window_Size, seq_num, payload를 결합한 후,  
     - 체크섬을 계산하여 헤더 앞에 추가한다.

2. **초기 윈도우 패킷 전송**  
   - 초기 윈도우에 포함된 모든 패킷을 순차적으로 전송하고, 각 전송 이벤트를 로그에 기록한다.

3. **ACK 수신 및 윈도우 이동**  
   - UDP 소켓의 타임아웃(0.01초) 내에 ACK를 수신하기 위해 반복문에 진입한다.
   - 수신한 ACK에서 시퀀스 번호를 추출하여, ACK가 현재 윈도우 내 패킷에 해당하는지 확인한다.
   - ACK가 올바른 경우, 해당 시퀀스 번호를 ACK 처리(mark_seq_num)하여 window_mark 배열에서 표시한다.
   - ACK가 기대하는 패킷(seq_num와 일치)이거나, 윈도우 내 연속적으로 ACK된 패킷들이 존재하면,  
     - `move_window()` 함수를 호출하여 윈도우를 앞으로 이동시킨다.
     - 이동된 후 새로 윈도우에 포함된 패킷은 파일에서 읽어 생성하며, 즉시 전송되고 로그에 기록된다.
   - 만약 ACK의 시퀀스 번호가 올바르지 않거나 타임아웃이 발생하면,  
     - 타임아웃 로그를 기록하고, 윈도우의 첫 번째 패킷을 재전송하며 SEND_DATA_AGAIN 로그를 기록한다.

4. **종료 처리**  
   - 모든 패킷에 대한 ACK가 수신되어 윈도우가 비워지면 전송을 종료하고, 최종 로그를 기록한다.

---
