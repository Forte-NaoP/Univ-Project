# RDT 3.0

---

## 1. 패킷 구조  
패킷은 8바이트 헤더와 payload로 구성된다.  
헤더 구성은 다음과 같다.  
- **checkSum (2바이트):** 패킷 전체의 무결성을 검증하기 위해 계산된 체크섬이다.  
- **end_flag (1바이트):** 0이면 마지막 패킷임을, 1이면 전송 중인 패킷임을 나타낸다.  
- **window_Size (1바이트):** 창 크기를 나타내지만, RDT 3.0에서는 pipelining이 적용되지 않아 단순 정보로 사용된다.  
- **seq_num (4바이트):** 시퀀스 번호로, 0과 1을 토글하며 패킷의 순서를 관리한다.

---

## 2. Receiver 동작 방식  
- UDP 소켓을 생성하고 포트 10090번에 바인딩한다.  
- 반복적으로 패킷을 수신한다.  
- 수신한 패킷에서 3번째 바이트(end_flag)와 4~8번째 바이트(seq_num)를 추출한다.  
- Receiver.verify_checksum 함수를 호출하여 패킷의 체크섬을 검증한다.  
- 체크섬 검증에 실패하거나, 예상 시퀀스 번호(receiver.next_seq_num())와 수신한 seq_num이 일치하지 않으면  
  - 로그에 CORRUPTED 상태를 기록하고,  
  - 현재 예상 시퀀스 번호를 포함한 ACK를 재전송한다.  
- 정상 패킷의 경우 헤더 이후의 payload를 파일에 기록한다.  
- 로그에 SUCCESS_ACK 상태를 기록한 후, 시퀀스 번호를 토글한다.  
- ACK를 전송한다.  
- end_flag가 0이면 마지막 패킷으로 간주하고 수신 루프를 종료한다.  
- 전송 종료 후 로그 기록을 마친다.

---

## 3. Sender 동작 방식  
- UDP 소켓을 생성하고 포트 번호 10090으로 통신한다.  
- 소켓 타임아웃을 0.01초로 설정하여 ACK 수신을 기다린다.  
- Payload 클래스가 파일을 열어 MAX_READ_SIZE만큼 데이터를 읽고,  
  - 각 청크에 대해 end_flag, window_size, seq_num을 포함하는 헤더를 생성한다.  
  - 체크섬을 계산하여 헤더 앞에 추가한다.  
  - 최종 패킷을 생성하여 yield로 반환한다.
- for 루프를 통해 생성된 각 패킷을 순차적으로 전송한다.  
- 패킷 전송 후 로그에 SEND_DATA 이벤트를 기록한다.
- 전송한 패킷에 대해 ACK를 수신하기 위해 while 루프에 진입한다.  
  - try 블록 내에서 udp_socket.recvfrom를 통해 8바이트 크기의 ACK를 수신한다.  
  - ACK에서 시퀀스 번호를 추출한다.  
  - 만약 ACK의 시퀀스 번호가 현재 전송한 패킷의 seq_num과 일치하면  
    - SUCCESS_ACK 로그를 기록하고,  
    - 다음 상태로 넘어가기 위해 루프를 종료한다.  
  - 만약 ACK의 시퀀스 번호가 일치하지 않으면  
    - WRONG_SEQ_NUM 로그를 기록하고,  
    - 동일한 패킷을 재전송하며 SEND_DATA_AGAIN 로그를 기록한다.
- ACK를 수신하지 못해 타임아웃이 발생하면  
  - 타임아웃 로그를 기록하고,  
  - 동일한 패킷을 재전송하며 SEND_DATA_AGAIN 로그를 기록한다.
- 정상 ACK 수신 후 시퀀스 번호를 토글한다.  
- 모든 패킷 전송이 완료되면 전송 종료 로그를 기록한다.

---
