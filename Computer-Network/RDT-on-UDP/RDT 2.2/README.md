# RDT 2.2

---

## 1. 패킷 구조

RDT 2.2에서는 패킷 헤더가 확장되어 총 8바이트로 구성된다.

```
| checkSum (2바이트) | end_flag (1바이트) | window_Size (1바이트) | seq_num (4바이트) | ...payload ... |
```

- **checkSum (2바이트):**  
  전체 패킷(헤더+payload)에 대해 계산된 체크섬. 수신 측에서는 이 값이 올바른지 검증하여 패킷의 무결성을 확인한다.
- **end_flag (1바이트):**  
  0이면 마지막 패킷임을, 1이면 전송 중인 패킷임을 나타낸다.
- **window_Size (1바이트):**  
  현재 윈도우 크기를 나타내지만, RDT 2.2에서는 사용되지 않는다.
- **seq_num (4바이트):**  
  시퀀스 번호로, 전송 패킷의 순서를 관리하며 기본적으로 0과 1을 토글함.

---

## 2. Receiver 코드 설명 (receiver.py)

### 주요 역할
- **패킷 수신 및 검증:**  
  UDP 소켓을 통해 1500바이트 단위의 패킷을 수신하고, 헤더에 포함된 체크섬과 시퀀스 번호를 확인한다.
  
- **파일 기록 및 ACK 전송:**  
  올바른 패킷의 payload를 파일에 기록한 후, ACK를 생성하여 송신자에게 전송한다.

### 세부 동작

1. **소켓 설정 및 바인딩:**  
   - 포트 번호 10090번에서 UDP 소켓을 생성, 옵션 `SO_REUSEADDR`을 설정하고 바인딩

2. **로그 기록:**  
   - `logHandler` 모듈을 이용해 로그 파일을 시작한다. 로그에는 ACK 전송, 잘못된 패킷 수신 등 상태를 기록한다.

3. **패킷 처리 루프:**
   - **패킷 수신:**  
     - `udp_socket.recvfrom(1500)`를 통해 패킷을 수신한다.
   - **헤더 분리:**  
     - 헤더 내에서 `end_flag` (payload의 3번째 바이트)와 `seq_num` (4번째~8번째 바이트)를 추출한다.
   - **체크섬 검증:**  
     - `verify_checksum` 정적 메서드를 사용하여 패킷의 무결성을 확인한다.  
     - 체크섬이 올바르지 않거나, 기대하는 시퀀스 번호(`receiver.next_seq_num()`)와 불일치하면,  
       - 손상된 패킷으로 간주하여 해당 상태를 로그에 남기고(예: CORRUPTED, SEND_ACK_AGAIN)  
       - Receiver의 현재 예상 시퀀스 번호를 포함한 ACK를 송신한다.
   - **정상 패킷 처리:**  
     - 체크섬이 올바르고 시퀀스 번호가 일치하면,  
       - 헤더를 제외한 payload를 파일에 기록하고,  
       - ACK 전송 이벤트를 로그에 기록한 후,  
       - Receiver의 시퀀스 번호를 토글하여 다음 패킷을 준비한다.
   - **전송 종료:**  
     - `end_flag`가 0이면 마지막 패킷으로 간주하여 루프를 종료한다.

4. **ACK 생성:**  
   - `ack()` 메서드는 현재 시퀀스 번호를 포함하는 ACK 패킷을 생성한다.
   
5. **체크섬 검증 함수:**  
   - `verify_checksum` 메서드는 패킷 데이터(홀수 길이일 경우 패딩 추가)에 대해 2바이트 단위로 합산, 캐리 처리를 한 후 최종 값이 `0xffff`와 일치하는지 확인한다.

---

## 3. Sender 코드 설명 (sender.py)

### 주요 역할
- **파일 읽기 및 패킷 생성:**  
  파일을 일정 크기(MAX_READ_SIZE)로 읽어 헤더(체크섬, end_flag, window_size, 시퀀스 번호)를 추가하여 패킷을 생성한다.
  
- **패킷 전송 및 ACK 처리:**  
  각 패킷을 전송 후, 송신 측은 올바른 ACK를 받을 때까지 대기하며, ACK가 올바르지 않은 경우 재전송을 수행한다.

### 세부 동작

1. **패킷 헤더 생성 및 체크섬 계산:**
   - **Payload 클래스:**  
     - 파일 크기와 초기 시퀀스 번호(0) 및 윈도우 크기(파라미터로 전달)를 초기화.
     - `get_payload()` 메서드:  
       - 파일에서 최대 `MAX_READ_SIZE`(=1460-8)만큼 읽어 데이터를 청크로 생성한다.
       - 각 패킷에 대해:
         - **end_flag:** 파일 포인터(`file.tell()`)가 파일 크기와 같으면 0, 아니면 1.
         - **window_size:** 생성된 윈도우 크기를 1바이트로 패킹.
         - **seq_num:** 현재 시퀀스 번호를 4바이트 정수로 패킹.
       - 위 필드들을 결합한 후, 전체 패킷의 체크섬을 계산하여 2바이트로 prepend 한다.
       - 최종 패킷은 `checkSum + end_flag + window_size + seq_num + payload`로 구성된다.
     - `next_seq_num()` 메서드:  
       - 시퀀스 번호를 XOR 연산(`^= 1`)으로 토글한다.

2. **소켓 생성 및 설정:**  
   - 송신 측도 포트 10090번으로 연결할 UDP 소켓을 생성하고, `SO_REUSEADDR` 옵션을 설정한다.

3. **PASender 모듈 사용:**  
   - PASender.PASender 클래스를 통해 전송 환경(예: 시뮬레이션 설정)을 구성한다. (config.txt를 이용)
   
4. **로그 기록:**  
   - `logHandler`를 통해 전송 및 ACK 수신 관련 이벤트(예: SEND_DATA, SUCCESS_ACK, WRONG_SEQ_NUM, SEND_DATA_AGAIN)를 기록한다.

5. **패킷 전송 및 ACK 대기 루프:**
   - `Payload.get_payload()` 메서드로 생성한 각 패킷에 대해:
     - **패킷 전송:**  
       - `sender.sendto_bytes(payload, (receiver_ip, PORT_NUMBER))`를 호출하여 패킷을 전송하고,  
       - 전송 이벤트를 로그에 기록한다.
     - **ACK 대기:**  
       - `udp_socket.recvfrom(8)`를 통해 8바이트 크기의 ACK를 대기한다.
       - 수신한 ACK에서 시퀀스 번호(바이트 4~8)를 추출한다.
       - 만약 ACK의 시퀀스 번호가 현재 전송한 패킷의 시퀀스 번호와 일치하면,  
         - 성공 로그를 기록하고, 다음 패킷으로 넘어감.
       - 그렇지 않은 경우(잘못된 시퀀스 번호라면),  
         - 해당 상태를 로그에 기록하고,  
         - 동일 패킷을 재전송하며 재전송 로그를 기록함.
     - **시퀀스 번호 토글:**  
       - 올바른 ACK를 받은 후 `next_seq_num()`을 호출하여 시퀀스 번호를 토글한다.
       
6. **전송 종료:**  
   - 모든 패킷 전송이 완료되면 로그 종료 이벤트(`logger.writeEnd()`)를 기록한다.

---